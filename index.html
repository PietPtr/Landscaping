<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<script src='vendor/three.js/build/three.min.js'></script>
<script src='vendor/three.js/examples/js/controls/OrbitControls.js'></script>
<div style='position: absolute; top: 0px; width: 100%;font-family:arial; font-weight: bolder; padding-top: 5px;'>

</div><body style='margin: 0px; overflow: hidden; text-align:center;'><script>
	function diamondSquare(n) {
		const BASEMOD = 400
		const TAPER = (modifier) => { return modifier / 1.45; };

		var size = Math.pow(2, n) + 1
		var modifier = BASEMOD;

		var map = new Array(size);
		for (var i = 0; i < size; i++) {
			map[i] = new Array(size);
		}

		for (var x = 0; x < size; x++) {
			for (var y = 0; y < size; y++) {
				map[x][y] = 0;
			}
		}

		for (var step = 0; step < n; step++) {
			var squareSize = Math.pow(2, n - step);

			for (var square = 0; square < Math.pow(4, step); square++) {
				var topleft = [
					Math.floor(square / Math.pow(2, step)) * squareSize,
					square % Math.pow(2, step) * squareSize
				];

				var center = [topleft[0] + squareSize / 2, topleft[1] + squareSize / 2];
				var average =
					(map[topleft[0]][topleft[1]] +
					map[topleft[0] + squareSize][topleft[1]] +
					map[topleft[0]][topleft[1] + squareSize] +
					map[topleft[0] + squareSize][topleft[1] + squareSize]) / 4;

				map[center[0]][center[1]] = average + (Math.random() - 0.5) * modifier;
			}

			modifier = TAPER(modifier);


			var point = 0;
			var gridWidth = Math.pow(2, step+1) + 1;
			var diamondSize = squareSize / 2;
			for (var x = 0; x < gridWidth; x++) {
				for (var y = 0; y < gridWidth; y++) {
					if (point % 2 == 1) {
						mapx = x * diamondSize;
						mapy = y * diamondSize;

						sum = 0;
						summedDirections = 0

						for (let direction of [[-1, 0], [0, -1], [1, 0], [0, 1]]) {
							neighbourx = mapx + direction[0] * diamondSize;
							neighboury = mapy + direction[1] * diamondSize;

							if (neighbourx >= 0 && neighboury >= 0 && neighbourx < size && neighboury < size) {
								sum += map[neighbourx][neighboury];
								summedDirections++;
							}
						}

						average = sum / summedDirections;
						map[mapx][mapy] = average + (Math.random() - 0.5) * modifier;
					}
					point += 1
				}
			}

			modifier = TAPER(modifier);
		}

		return map
	}

	function smooth(map) {
		for (var y = 0; y < map.length; y++) {
			for (var x = 0; x < map.length; x++) {
				sum = 0;
				summed = 0;

				for (var nx = -1; nx <= 1; nx++) {
					for (var ny = -1; ny <= 1; ny++) {
						neighbourx = x + nx;
						neighboury = y + ny;

						if (neighbourx >= 0 && neighboury >= 0 &&
							neighbourx < map.length && neighboury < map.length) {
							summed += 1;
							sum += map[neighbourx][neighboury];
						}
					}
				}
			}
		}

		return map;
	}

	function getNormal(p1, p2, p3) {
		let vx = p2.x - p1.x;
		let vy = p2.y - p1.y;
		let vz = p2.z - p1.z;
		let wx = p3.x - p1.x;
		let wy = p3.y - p1.y;
		let wz = p3.z - p1.z;

		let nx = (vy * wz) - (vz * wy);
		let ny = (vz * wx) - (vx * wz);
		let nz = (vx * wy) - (vy * wx);

		let length = Math.abs(nx) + Math.abs(ny) + Math.abs(nz);
		let ax = nx / length;
		let ay = ny / length;
		let az = nz / length;

		return new THREE.Vector3(ax, ay, az);
	}

	function getSquareMesh(map, n) {
		var size = Math.pow(2, n-1)
		var geometry = new THREE.Geometry();

		for (var x = -size; x <= size; x++) {
			for (var z = -size; z <= size; z++) {
				geometry.vertices.push(new THREE.Vector3(x, map[x+size][z+size], z));
			}
		}

		for (var z = 0; z < size*2; z++) {
			for (var x = 0; x < size*2; x++) {
				var base = x + z * (size * 2 + 1)

				right = base + 1
				under = base + size * 2 + 1;
				rightUnder = base + size * 2 + 2;

				geometry.faces.push( new THREE.Face3(
					rightUnder,
					under,
					base,
					getNormal(geometry.vertices[under], geometry.vertices[base], geometry.vertices[rightUnder]),
					new THREE.Color(0xffffff)
				));

				geometry.faces.push( new THREE.Face3(
					base,
					right,
					rightUnder,
					getNormal(geometry.vertices[base], geometry.vertices[right], geometry.vertices[rightUnder]),
					new THREE.Color(0xffffff)
				))
			}
		}

		geometry.computeBoundingSphere();
		return geometry;
	}

	function moveLight(delta, now) {
		console.log(delta, now, lightAngle);
		lightAngle += delta * 2;
		light.position.x = Math.cos(lightAngle) * 150;
		light.position.z = Math.sin(lightAngle) * 150;
		light.position.y = 230 + Math.sin(lightAngle) * 50;

		sphere.position = light.position;

	}

	//////////////////////////////////////////////////////////////////////////////////
	//		Init
	//////////////////////////////////////////////////////////////////////////////////

	// init renderer
	var renderer	= new THREE.WebGLRenderer({
		antialias	: true
	});
	renderer.setClearColor(new THREE.Color('#0c0c0c'), 1)
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	// array of functions for the rendering loop
	var onRenderFcts= [];

	// init scene and camera
	var scene	= new THREE.Scene();
	var camera	= new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
	camera.position.x = 400
	camera.position.y = 200
	var controls	= new THREE.OrbitControls(camera)

	//////////////////////////////////////////////////////////////////////////////////
	//		add an object in the scene
	//////////////////////////////////////////////////////////////////////////////////

	// var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
	// scene.add( directionalLight );

	var lightAngle = 0
	var light = new THREE.PointLight( 0xffffab, 1, 1000 );
	light.position.set( 0, 200, 0 );
	scene.add( light );

	var geometry = new THREE.SphereGeometry(1, 5, 5);
	var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
	var sphere = new THREE.Mesh( geometry, material );
	scene.add( sphere );

	var n = 9
	var geometry = getSquareMesh(diamondSquare(n), n);
	var material = new THREE.MeshPhongMaterial();
	var mesh = new THREE.Mesh(geometry, material);
	mesh.geometry.computeVertexNormals();
	scene.add(mesh);

	//////////////////////////////////////////////////////////////////////////////////
	//		render the whole thing on the page
	//////////////////////////////////////////////////////////////////////////////////

	// handle window resize
	window.addEventListener('resize', function(){
		renderer.setSize( window.innerWidth, window.innerHeight )
		camera.aspect	= window.innerWidth / window.innerHeight
		camera.updateProjectionMatrix()
	}, false)

	// render the scene
	onRenderFcts.push(function(){
		renderer.render( scene, camera );
	})

	onRenderFcts.push(moveLight);

	// run the rendering loop
	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000)
		})
	})
</script></body>
